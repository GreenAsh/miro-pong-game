<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" type="text/css" href="https://realtimeboard.com/app/static/rtb.uikit.css">
	<script src="https://realtimeboard.com/app/static/rtb.sdk.1.0.js"></script>

	<style>
		.rtb-sidebar-caption {
			font-size: 14px;
			font-weight: bold;
			color: rgba(0, 0, 0, 0.8);
			padding: 24px 0 0 24px;
		}

		.actions {
			padding: 20px 24px 0 24px;
		}

		button {
			height: 32px;
			border-radius: 4px;
			font-size: 12px;
			font-weight: bold;
			line-height: 30px;
			text-align: center;
			color: #fff;
			min-width: 65px;
			background-color: #2a79ff;
			overflow: hidden;
			text-overflow: ellipsis;
		}
	</style>
	<script src="sound.js"></script>
	<script src="global.js"></script>
	<script src="mapData.js"></script>
	<script src="engineAndMap.js"></script>
	<script src="setup.js"></script>
	<script src="input.js"></script>
</head>

<body>
	<div class="rtb-sidebar-caption">Ping-pong</div>
	<div class="actions">
		<center>
			<br><br>
			<button onclick="app.createSession()" style="width: 120px;">be Hostest!</button><br />
			<button onclick="app.run()" style="width: 120px;">Start [Host]!</button><br />
			<button onclick="app.stop()" style="width: 120px;">Stop [Host]!</button><br />
			<h2 id="serverStatus" style=""></h2>
			<button onclick="app.join()" style="width: 120px;">Join... as client!</button><br />
			<h2 id="errorMessage" style=""></h2>
			<br><br>
			<h2 id="controls" style="display:none;">Use up/down arrows and A/Z keys to control pad</h2>
			<h2 id="you-are-dead" style="display:none; background-color: red;">You are dead, reopen sidebar and click 'Play'!</h2>
			<h2 id="click-for-focus" style="display:none;">Click on sidebar <br>to control pad</h2>
		</center>
	</div>
	<script>
		'use strict'
		const STOPPED = 0;
		const AWAITING = 1;
		const STARTED = 2;

		const PREPARE = "prepare";
		const START = "start";
		const STOP = "stop";
		const STATE = "state";
		const JOIN = "join";
		const MOVE_LEFT = "moveLeft";
		const MOVE_RIGHT = "moveRight";

		const BALL_LOOP = 20;

		let app = {
			hosted: false,
			joined: false,
			lastCommand: null,
			lastMessage: null,
			ballLoop: null,
			ballDirection: null,
			socket: null,
			started: false,
			init: function(){
				this.socket = new WebSocket("wss://24b4856f.ngrok.io", "protocolOne");
				this.socket.onmessage = app.onmessage;
			},
			onmessage: function(event){
				console.log(event.data);
				app.lastMessage = JSON.parse(event.data);
				let message = "Unknown status";
				switch (app.lastMessage.state) {
					case STOPPED:
						app.started = false;
						message = "Game is Stopped, please create session";
						if (app.ballLoop){
							clearInterval(app.ballLoop);
							document.onkeydown = function(){};
						}
						break;
					case AWAITING:
						message = "Game is in awaiting status";
						break;
					case STARTED:
						if (app.started === false) {
							app.started = true;
							if (app.joined) {
								//ToDo alalala
								// mapDeepCopy(world.initialMap, world.dirtyMap);
								// world.ball.init(5, 16);
								// world.pads[0].init(4, 1);
								// world.pads[1].init(4, 17);
								input.asClient(app);
							}
							if (app.hosted === true) {
								input.asHost();
								app.ballDirection = {x: -1, y: -1};
								app.ballLoop = setInterval(() => {
									if (world.ball.move(app.ballDirection.x, app.ballDirection.y)) {
										renderer.redrawMap();
									} else {
										const x = app.ballDirection.x
										const width = world.ball.width
										if (world.ball.getCurPos().x + x < 0 || (world.ball.getCurPos().x + x + width) > WIDTH || world.map[world.ball.getCurPos().x
										+ x][world.ball.getCurPos().y] !== VOID) {
											app.ballDirection.x = -x;
										}
										const y = app.ballDirection.y
										const height = world.ball.height
										if (world.ball.getCurPos().y + y < 0 || (world.ball.getCurPos().y + y + height) > HEIGHT
											|| world.map[world.ball.getCurPos().x][world.ball.getCurPos().y + y] !== VOID) {
											app.ballDirection.y = -y;
										}
										let xCollision = world.map[world.ball.getCurPos().x + x][world.ball.getCurPos().y];
										let yCollision = world.map[world.ball.getCurPos().x][world.ball.getCurPos().y + y];

										if (xCollision === WALL || yCollision === WALL){
											sound.plop.play();
										}
										if (xCollision === PAD || yCollision === PAD){
											sound.beep.play();
										}
										if (xCollision === INVISIBLE || yCollision === INVISIBLE){
											sound.peep.play();
										}

										if (world.ball.move(app.ballDirection.x, app.ballDirection.y)) {
											renderer.redrawMap();
										} else {
											app.ballDirection.x = -x;
											app.ballDirection.y = -y;
											if (world.ball.move(app.ballDirection.x, app.ballDirection.y)) {
												renderer.redrawMap();
											}
										}
									}
								}, BALL_LOOP);
							}
							message = "Game is started";
						}
						break;
				}
				if (app.lastMessage.host === true){
					app.hosted = true;
					//ToDo responsibility
					renderer.init();
					document.getElementById("serverStatus").innerText = "You are the host";
				} else {
					document.getElementById("serverStatus").innerText = message;
				}
				if (app.lastMessage.errorMessage != null){
					document.getElementById("errorMessage").innerText = app.lastMessage.errorMessage;
				}
				if (app.lastMessage.command != null){
					switch (app.lastMessage.command) {
						case "joined":
							if (app.lastCommand === JOIN){
								app.joined = true;
							}
							break;
						case MOVE_LEFT:
							if (app.started === true && app.hosted === true && world.pads[0].move(-1, 0)){
								renderer.redrawMap();
							}
							break;
						case MOVE_RIGHT:
							if (app.started === true && app.hosted === true && world.pads[0].move(1, 0)){
								renderer.redrawMap();
							}
							break;
					}
				}
			},
			createSession: function() {
				this.lastCommand = PREPARE;
				this.socket.send(PREPARE);
			},
			run: function(){
				this.lastCommand = START;
				this.socket.send(START)
			},
			stop: function(){
				this.lastCommand = STOP;
				this.socket.send(STOP)
			},
			join: function () {
				this.lastCommand = JOIN;
				this.socket.send(JOIN)
			},
			moveLeft: function(){
				if (this.lastMessage.state === STARTED && this.joined === true) {
					this.socket.send(MOVE_LEFT);
				}
			},
			moveRight: function(){
				if (this.lastMessage.state === STARTED && this.joined === true) {
					this.socket.send(MOVE_RIGHT);
				}
			}
		};

		app.init();
	</script>
</body>

</html>